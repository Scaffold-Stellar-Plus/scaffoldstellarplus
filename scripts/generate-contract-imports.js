#!/usr/bin/env node

/**
 * Generates contract import files in frontend/contracts/ based on packages in frontend/packages/
 * Keeps util.ts unchanged and auto-generates all other contract files
 */

const fs = require('fs');
const path = require('path');

// Paths
const PACKAGES_DIR = path.join(__dirname, '../frontend/packages');
const CONTRACTS_DIR = path.join(__dirname, '../frontend/contracts');

// Ensure contracts directory exists
if (!fs.existsSync(CONTRACTS_DIR)) {
  fs.mkdirSync(CONTRACTS_DIR, { recursive: true });
}

/**
 * Generate contract import file content
 */
function generateContractFile(contractName) {
  return `import * as Client from '../packages/${contractName}/dist';
import { rpcUrl, networkPassphrase } from './util';

export default new Client.Client({
  ...Client.networks.testnet,
  networkPassphrase,
  rpcUrl,
  allowHttp: true,
});
`;
}

/**
 * Generate contract map file content
 */
function generateContractMapFile(packages) {
  const importStatements = packages.map(pkg => 
    `  '${pkg}': () => import('@/contracts/${pkg}'),`
  ).join('\n');
  
  // Also include Title Case versions for user-friendly names
  const titleCaseImports = packages.map(pkg => {
    const titleCase = pkg.split('_').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
    return `  '${titleCase}': () => import('@/contracts/${pkg}'),`;
  }).join('\n');

  return `/**
 * Auto-generated contract map
 * Generated by: generate-contract-imports.js
 * Do not edit manually - this file is regenerated on each deployment
 */

export const contractMap: Record<string, () => Promise<any>> = {
${importStatements}
${titleCaseImports}
};

/**
 * Get a list of all available contract names
 */
export function getAvailableContracts(): string[] {
  return [${packages.map(pkg => `'${pkg}'`).join(', ')}];
}
`;
}

/**
 * Main function
 */
function generateContractImports() {
  // Check if packages directory exists
  if (!fs.existsSync(PACKAGES_DIR)) {
    console.error('❌ Packages directory not found');
    process.exit(1);
  }

  // Get all packages
  const packages = fs.readdirSync(PACKAGES_DIR).filter(item => {
    const itemPath = path.join(PACKAGES_DIR, item);
    return fs.statSync(itemPath).isDirectory() && 
           fs.existsSync(path.join(itemPath, 'package.json'));
  });

  if (packages.length === 0) {
    console.log('⚠️  No packages found');
    return;
  }

  // Generate contract files
  const builtPackages = [];

  packages.forEach(packageName => {
    const contractFilePath = path.join(CONTRACTS_DIR, `${packageName}.ts`);
    
    // Check if dist directory exists (package must be built)
    const distPath = path.join(PACKAGES_DIR, packageName, 'dist');
    if (!fs.existsSync(distPath)) {
      return;
    }

    // Generate the contract file
    const content = generateContractFile(packageName);
    fs.writeFileSync(contractFilePath, content, 'utf8');
    builtPackages.push(packageName);
  });

  // Generate contract map file
  if (builtPackages.length > 0) {
    const contractMapPath = path.join(__dirname, '../frontend/lib/contract-map.ts');
    const contractMapContent = generateContractMapFile(builtPackages);
    fs.writeFileSync(contractMapPath, contractMapContent, 'utf8');
  }

  // Ensure util.ts exists
  const utilPath = path.join(CONTRACTS_DIR, 'util.ts');
  if (!fs.existsSync(utilPath)) {
    const utilContent = `export const rpcUrl = process.env.NEXT_PUBLIC_RPC_URL ?? "https://soroban-testnet.stellar.org:443"
export const networkPassphrase = process.env.NEXT_PUBLIC_STELLAR_NETWORK_PASSPHRASE ?? "Test SDF Network ; September 2015"

// Re-export for easy access
export { rpcUrl as rpc, networkPassphrase as passphrase }
`;
    fs.writeFileSync(utilPath, utilContent, 'utf8');
  }

  console.log(`✅ Generated imports for ${builtPackages.length} contracts`);
}

// Run the script
try {
  generateContractImports();
} catch (error) {
  console.error('❌ Error generating contract imports:', error.message);
  
  // Log detailed error information
  if (error.stderr) {
    console.error('\x1b[90mStderr:\x1b[0m')
    console.error('\x1b[90m' + error.stderr.toString() + '\x1b[0m')
  }
  if (error.stack) {
    console.error('\x1b[90m' + error.stack + '\x1b[0m')
  }
  
  process.exit(1);
}

