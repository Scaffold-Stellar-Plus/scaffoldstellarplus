#!/usr/bin/env node

/**
 * Generates network-aware contract import files in frontend/contracts/
 * Keeps util.ts unchanged and auto-generates all other contract files with network separation
 */

const fs = require('fs');
const path = require('path');

// Paths
const PACKAGES_DIR = path.join(__dirname, '../frontend/packages');
const CONTRACTS_DIR = path.join(__dirname, '../frontend/contracts');

// Ensure contracts directory exists
if (!fs.existsSync(CONTRACTS_DIR)) {
  fs.mkdirSync(CONTRACTS_DIR, { recursive: true });
}

/**
 * Parse package name to extract contract name and network
 * e.g., "hello_world-testnet" => { contract: "hello_world", network: "testnet" }
 */
function parsePackageName(packageName) {
  const parts = packageName.split('-');
  const possibleNetworks = ['testnet', 'mainnet', 'futurenet'];
  const lastPart = parts[parts.length - 1];
  
  if (possibleNetworks.includes(lastPart)) {
    return {
      contract: parts.slice(0, -1).join('-'),
      network: lastPart
    };
  }
  
  // Fallback for packages without network suffix (legacy support)
  return {
    contract: packageName,
    network: 'unknown'
  };
}

/**
 * Generate contract import file content for a specific network
 */
function generateContractFile(packageName, contractName, network) {
  return `import * as Client from '../packages/${packageName}/dist';
import { rpcUrl, networkPassphrase } from './util';

export default new Client.Client({
  ...Client.networks.${network},
  networkPassphrase,
  rpcUrl,
  allowHttp: ${network !== 'mainnet'},
});
`;
}

/**
 * Group packages by contract name and network
 */
function groupPackagesByContract(packages) {
  const grouped = {};
  
  packages.forEach(packageName => {
    const { contract, network } = parsePackageName(packageName);
    
    if (!grouped[contract]) {
      grouped[contract] = {};
    }
    
    grouped[contract][network] = packageName;
  });
  
  return grouped;
}

/**
 * Generate contract map file content with network awareness
 */
function generateContractMapFile(groupedPackages) {
  const contracts = Object.keys(groupedPackages);
  const networks = ['testnet', 'mainnet', 'futurenet'];
  
  // Generate import entries for each contract-network combination
  const importEntries = [];
  
  contracts.forEach(contract => {
    networks.forEach(network => {
      const packageName = groupedPackages[contract][network];
      if (packageName) {
        importEntries.push(`  '${contract}-${network}': () => import('@/contracts/${contract}-${network}'),`);
      }
    });
  });

  // Also include Title Case versions for user-friendly names
  const titleCaseImports = [];
  contracts.forEach(contract => {
    networks.forEach(network => {
      const packageName = groupedPackages[contract][network];
      if (packageName) {
        const titleCase = contract.split('_').map(word => 
          word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
        const networkTitle = network.charAt(0).toUpperCase() + network.slice(1);
        titleCaseImports.push(`  '${titleCase} (${networkTitle})': () => import('@/contracts/${contract}-${network}'),`);
      }
    });
  });

  return `/**
 * Auto-generated contract map with network separation
 * Generated by: generate-contract-imports.js
 * Do not edit manually - this file is regenerated on each deployment
 * 
 * Contract packages are network-specific:
 * - contractName-testnet: Testnet deployment
 * - contractName-mainnet: Mainnet deployment
 * - contractName-futurenet: Futurenet deployment
 */

export const contractMap: Record<string, () => Promise<any>> = {
${importEntries.join('\n')}
${titleCaseImports.join('\n')}
};

/**
 * Get a list of all available contracts (without network suffix)
 */
export function getAvailableContracts(): string[] {
  return [${contracts.map(c => `'${c}'`).join(', ')}];
}

/**
 * Get a list of all available networks
 */
export function getAvailableNetworks(): string[] {
  return ['testnet', 'mainnet', 'futurenet'];
}

/**
 * Get contract key for a specific network
 * @param contractName - Base contract name (e.g., "hello_world")
 * @param network - Network name (e.g., "testnet", "mainnet")
 * @returns Contract map key (e.g., "hello_world-testnet")
 */
export function getContractKey(contractName: string, network: string): string {
  return \`\${contractName}-\${network}\`;
}

/**
 * Check if a contract is deployed on a specific network
 */
export function isContractDeployed(contractName: string, network: string): boolean {
  const key = getContractKey(contractName, network);
  return key in contractMap;
}
`;
}

/**
 * Main function
 */
function generateContractImports() {
  // Check if packages directory exists
  if (!fs.existsSync(PACKAGES_DIR)) {
    console.error('❌ Packages directory not found');
    process.exit(1);
  }

  // Get all packages
  const packages = fs.readdirSync(PACKAGES_DIR).filter(item => {
    const itemPath = path.join(PACKAGES_DIR, item);
    return fs.statSync(itemPath).isDirectory() && 
           fs.existsSync(path.join(itemPath, 'package.json'));
  });

  if (packages.length === 0) {
    console.log('⚠️  No packages found');
    return;
  }

  // Group packages by contract and network
  const groupedPackages = groupPackagesByContract(packages);

  // Generate contract files
  const builtPackages = [];

  packages.forEach(packageName => {
    const { contract, network } = parsePackageName(packageName);
    const contractFilePath = path.join(CONTRACTS_DIR, `${contract}-${network}.ts`);
    
    // Check if dist directory exists (package must be built)
    const distPath = path.join(PACKAGES_DIR, packageName, 'dist');
    if (!fs.existsSync(distPath)) {
      return;
    }

    // Generate the contract file
    const content = generateContractFile(packageName, contract, network);
    fs.writeFileSync(contractFilePath, content, 'utf8');
    builtPackages.push(packageName);
  });

  // Generate contract map file
  if (Object.keys(groupedPackages).length > 0) {
    const contractMapPath = path.join(__dirname, '../frontend/lib/contract-map.ts');
    const contractMapContent = generateContractMapFile(groupedPackages);
    fs.writeFileSync(contractMapPath, contractMapContent, 'utf8');
  }

  // Ensure util.ts exists
  const utilPath = path.join(CONTRACTS_DIR, 'util.ts');
  if (!fs.existsSync(utilPath)) {
    const utilContent = `export const rpcUrl = process.env.NEXT_PUBLIC_RPC_URL ?? "https://soroban-testnet.stellar.org:443"
export const networkPassphrase = process.env.NEXT_PUBLIC_STELLAR_NETWORK_PASSPHRASE ?? "Test SDF Network ; September 2015"

// Re-export for easy access
export { rpcUrl as rpc, networkPassphrase as passphrase }
`;
    fs.writeFileSync(utilPath, utilContent, 'utf8');
  }

  console.log(`✅ Generated network-aware imports for ${builtPackages.length} contract packages`);
  console.log(`   Contracts: ${Object.keys(groupedPackages).length} unique contracts`);
  console.log(`   Networks: ${Array.from(new Set(packages.map(p => parsePackageName(p).network))).join(', ')}`);
}

// Run the script
try {
  generateContractImports();
} catch (error) {
  console.error('❌ Error generating contract imports:', error.message);
  
  // Log detailed error information
  if (error.stderr) {
    console.error('\x1b[90mStderr:\x1b[0m')
    console.error('\x1b[90m' + error.stderr.toString() + '\x1b[0m')
  }
  if (error.stack) {
    console.error('\x1b[90m' + error.stack + '\x1b[0m')
  }
  
  process.exit(1);
}
