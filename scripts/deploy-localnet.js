#!/usr/bin/env node

const { execSync } = require('child_process')
const fs = require('fs')
const path = require('path')

const log = (message) => {
  console.log(`\n\x1b[1;32m[LOG] ${message}\x1b[0m`)
}

const error = (message) => {
  console.error(`\x1b[1;31m[ERROR] ${message}\x1b[0m`)
}

const checkPrerequisites = () => {
  log('Checking prerequisites...')
  
  try {
    execSync('stellar --version', { stdio: 'pipe' })
  } catch (err) {
    error('Stellar CLI not found. Please install it first.')
    process.exit(1)
  }

  try {
    execSync('rustup target list | grep "wasm32v1-none (installed)"', { stdio: 'pipe' })
  } catch (err) {
    log('Adding wasm32v1-none target...')
    execSync('rustup target add wasm32v1-none')
  }
}

const buildContracts = () => {
  log('Building contracts...')
  
  try {
    execSync('cd contracts && cargo build --target wasm32v1-none --release', { stdio: 'inherit' })
  } catch (err) {
    error('Failed to build contracts')
    process.exit(1)
  }
}

const detectContracts = () => {
  log('Auto-detecting contracts...')
  
  const contractsDir = 'contracts'
  const contracts = []
  
  if (!fs.existsSync(contractsDir)) {
    error('Contracts directory not found')
    return []
  }
  
  const items = fs.readdirSync(contractsDir)
  
  items.forEach(item => {
    const itemPath = path.join(contractsDir, item)
    const stat = fs.statSync(itemPath)
    
    if (stat.isDirectory()) {
      const cargoTomlPath = path.join(itemPath, 'Cargo.toml')
      const srcPath = path.join(itemPath, 'src')
      
      if (fs.existsSync(cargoTomlPath) && fs.existsSync(srcPath)) {
        contracts.push({
          name: item,
          path: itemPath
        })
      }
    }
  })
  
  log(`Found ${contracts.length} contracts: ${contracts.map(c => c.name).join(', ')}`)
  return contracts
}

const deployContract = (contractName, wasmPath) => {
  log(`Deploying ${contractName} contract to localnet...`)
  
  try {
    // Upload contract
    const uploadOutput = execSync(
      `stellar contract upload --network localnet --source alice --wasm ${wasmPath}`,
      { encoding: 'utf8' }
    )
    
    const wasmHash = uploadOutput.trim()
    log(`${contractName} wasm hash: ${wasmHash}`)
    
    // Deploy contract
    const deployOutput = execSync(
      `stellar contract deploy --wasm-hash ${wasmHash} --source alice --network localnet --alias ${contractName}`,
      { encoding: 'utf8' }
    )
    
    const contractId = deployOutput.trim()
    log(`${contractName} contract ID: ${contractId}`)
    
    return { wasmHash, contractId }
  } catch (err) {
    error(`Failed to deploy ${contractName}: ${err.message}`)
    process.exit(1)
  }
}

const generateContractBindings = (contracts) => {
  log('Generating TypeScript contract bindings...')
  
  try {
    // Create packages directory if it doesn't exist
    if (!fs.existsSync('frontend/packages')) {
      fs.mkdirSync('frontend/packages', { recursive: true })
    }
    
    // Generate bindings for each contract
    Object.entries(contracts).forEach(([contractName, contractInfo]) => {
      const outputDir = `frontend/packages/${contractName}`
      
      // Generate TypeScript bindings
      execSync(
        `stellar contract bindings typescript --network localnet --contract-id ${contractInfo.contractId} --output-dir ${outputDir}`,
        { stdio: 'inherit' }
      )
      
      log(`Generated bindings for ${contractName} in ${outputDir}`)
      
      // Fix stellar-sdk version to 14.0.0 (CLI generates with ^13.x by default)
      fixPackageJsonVersion(outputDir, contractName)
    })
  } catch (err) {
    error(`Failed to generate contract bindings: ${err.message}`)
  }
}

const fixPackageJsonVersion = (packageDir, contractName) => {
  try {
    const packageJsonPath = path.join(packageDir, 'package.json')
    
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'))
      
      // Update stellar-sdk version to 14.0.0
      if (packageJson.dependencies && packageJson.dependencies['@stellar/stellar-sdk']) {
        const oldVersion = packageJson.dependencies['@stellar/stellar-sdk']
        packageJson.dependencies['@stellar/stellar-sdk'] = '14.0.0'
        
        // Write back to file
        fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n', 'utf8')
        log(`Fixed stellar-sdk version for ${contractName}: ${oldVersion} â†’ 14.0.0`)
      }
    }
  } catch (err) {
    log(`Warning: Could not fix package.json for ${contractName}: ${err.message}`)
  }
}

const generateEnvFile = (contracts) => {
  log('Generating environment file...')
  
  const envContent = `# Auto-generated by deployment script
NEXT_PUBLIC_STELLAR_NETWORK=localnet
NEXT_PUBLIC_RPC_URL=http://localhost:8000/soroban/rpc
${Object.entries(contracts).map(([name, info]) => 
  `NEXT_PUBLIC_${name.toUpperCase()}_CONTRACT_ID=${info.contractId || ''}`
).join('\n')}
`
  
  fs.writeFileSync('.env.local', envContent)
  log('Environment file created: .env.local')
}

const generateDeploymentInfo = (contracts) => {
  log('Generating deployment info...')
  
  const deploymentInfo = {
    network: 'localnet',
    timestamp: new Date().toISOString(),
    contracts: Object.fromEntries(
      Object.entries(contracts).map(([name, info]) => [
        name,
        {
          contractId: info.contractId,
          wasmHash: info.wasmHash
        }
      ])
    )
  }
  
  fs.writeFileSync(
    'deployment.json', 
    JSON.stringify(deploymentInfo, null, 2)
  )
  log('Deployment info saved: deployment.json')
}

const main = async () => {
  try {
    checkPrerequisites()
    buildContracts()
    
    const detectedContracts = detectContracts()
    
    if (detectedContracts.length === 0) {
      error('No contracts found to deploy')
      process.exit(1)
    }
    
    const contracts = {}
    
    // Deploy each contract
    for (const contract of detectedContracts) {
      const wasmPath = `contracts/target/wasm32v1-none/release/${contract.name}.wasm`
      const result = deployContract(
        contract.name,
        wasmPath
      )
      if (result) {
        contracts[contract.name] = result
      }
    }
    
    generateContractBindings(contracts)
    generateEnvFile(contracts)
    generateDeploymentInfo(contracts)
    
    log('Deployment completed successfully!')
    log('Contract IDs:')
    Object.entries(contracts).forEach(([name, info]) => {
      log(`  ${name}: ${info.contractId}`)
    })
    
  } catch (err) {
    error(`Deployment failed: ${err.message}`)
    process.exit(1)
  }
}

if (require.main === module) {
  main()
}
